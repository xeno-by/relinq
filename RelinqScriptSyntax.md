Relinq is a tool for bi-directional transformation between [C# 3.0](http://download.microsoft.com/download/3/8/8/388e7205-bc10-4226-b2a8-75351c669b09/csharp%20language%20specification.doc) expression trees and expressions of [EcmaScript v3](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) (referenced versions of languages are shorthanded as C# and JS on this site). Framework provides means of programmatically building a strongly-typed C# expression tree that is equivalent to a given JS expression provided certain conditions are met.

[The JS -> C# transformation](http://code.google.com/p/relinq/wiki/JSToCSharp) starts with syntax verification of provided JS code that makes sure that the code doesn't contain unsupported language constructs that apriori can't be transformed to C#. Upon success of verification Relinq starts actual compilation that builds an equivalent C# expression tree and resolves member access.

RelinqScript is a sub-set of [ECMAScript v3](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) (shorthanded as JS here) that is [syntactically compatible](http://code.google.com/p/relinq/wiki/UnsupportedJSConstructs) with the transformation process. This document describes its lexer and parser along with the produced AST.

### JS grammar AST ###

To perform quite non-trivial and monotonous work of lexing/parsing source JS code string, Relinq uses [an ANTLR parser generator tool](http://antlr.org/) and [a complete ECMAScript 3 grammar for ANTLR 3](http://research.xebic.com/es3/) modified to support C# codegeneration. ANTLR is capable of generating lexer+parser suite that takes care of lexical/syntactical analysis of the code and builds the AST that corresponds to the code provided (or yields an informative error).

Nothing fancy to say here since ANTLR is quite a reliable and respected tool, and we can pretty much treat is as a black box. Let's just see an example of analyzing JS code equivalent to the simple LINQ query from the main page. Below you can find the JS and corresponding abstract syntax tree (image is generated by [ANTLRWorks](http://www.antlr.org/works/index.html)):

```
ctx.Companies.Where(function(c){
  return c.Employees.Count == 2;
}).Select(function(c){
  return {Name : c.Name};
});
```

http://relinq.googlecode.com/svn/wiki/images/antlrAst.PNG

### RelinqScript AST ###

RelinqScript is a sub-set of [ECMAScript v3](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) (shorthanded as JS here) that doesn't contain [unsupported language constructs](http://code.google.com/p/relinq/wiki/UnsupportedJSConstructs). Its parser takes AST created at the previous step, [analyzes, validates and transforms it into an internal AST](http://code.google.com/p/relinq/wiki/BuildingRelinqScriptAst) that is ready to be processed by the compiler. This AST consists from one of the following nodes linked into a hierarchical structure:

| Expression type | Structural notes | Notes |
|:----------------|:-----------------|:------|
| Keyword         | Leaf node        | Represents a single keyword of RelinqScript: `ctx` that corresponds to the data context that hosts `IQueryable` beans. |
| Variable        | Leaf node        | Denotes usage of a declared variable (11.1.2 Identifier Reference). If the usage is inconsistent (say, it's referenced within the closure that doesn't define the variable) a compilation error will occur later. |
| Constant        | Leaf node        | Represents an in-place definition of an object that doesn't involve any constructors (correspond to [json-serialized](http://code.google.com/p/relinq/wiki/JsonSerialization) ConstantExpressions of C# expression trees). Maps on either a json-style object initializer (11.1.5 Object Initialiser), or an array initialize (11.1.4 Array Initialiser) or a JS literal (7.8 Literals). |
| New             | Has `1..*` children | So far is used solely for creating instances of anonymous types, so doesn't support invoking constructors of explicitly declared types. Maps on a json-style object initializer (11.1.5 Object Initialiser) and stores a name -> expression mapping of the object's structure. |
| Lambda          | Has 1 child      | Corresponds to a function expression (13 Function Definition, "FunctionExpression" production), stores all argument names and a reference to the body - its single child. |
| MemberAccess    | Has 1 child      | Represents a field-style member access (11.2.1 Property Accessors) that doesn't use bracket notation, i.e. either dereferencing a field or a property or defining a method group. |
| Invoke          | Has 1 + `0..*` children | Is used to express a call-style member access including early- and late-bound calls (not including operators tho), namely: 11.2.3 Function Calls and 11.2.1 Property Accessors, bracket productions. |
| Indexer         | Has 1 + `0..*` children | Corresponds to bracket-based member access syntax constucts, namely: 11.2.1 Property Accessors, bracket productions. |
| Operator        | Has `1..2` children | Represents usage of [one of the supported operators](http://code.google.com/p/relinq/wiki/UnsupportedJSConstructs) described in 11 Expressions. Needs node type separate from the Invoke because it might reference one of the predefined operators that do not have implementing methods and some of those can't be expressed by method semantics (e.g. logical conditional operators). http://relinq.googlecode.com/svn/wiki/images/allRelinqOperators.PNG |
| Conditional     | Has 3 children   | The only one supported language construct that offers functionality from the statements world. Works and is parsed according to 11.12 Conditional Operator ( ?: ). |