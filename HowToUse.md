Welcome to the [first public release of Relinq](http://code.google.com/p/relinq/downloads/detail?name=relinq-v1.5-r1984.zip)! This version implements most of the stuff described in the specification (spec resides at the [project's wiki](http://code.google.com/p/relinq/w/list)) and provides an interactive console along with some test data to play with. There are still some not yet implemented things and a bunch of bugs (some of those described in [StuffToDo](StuffToDo.md), some of those lurking deep in the code and waiting for careless users).

### What is Relinq good for? ###
As the [main page](http://code.google.com/p/relinq/) says, Relinq is designed as a comprehensive tool for bi-directional transformation between C# 3.0 expression trees and expressions of EcmaScript v3. In fact, it's a bridge between dynamic (possibly, .NET-agnostic) environments and arbitrary .NET applications.  Below are the most prominent **scenarios that can be implemented with Relinq** ([HowToUse](HowToUse.md) document contains description of Relinq from a user viewpoint and has instructions on reproducing these scenarios in arbitrary applications):
  * **Querying LINQ datasources from JavaScript**. Relinq provides a framework for processing remote queries to LINQ-enabled datasources from languages and environments that are .NET/LINQ-agnostic. By implementing a service endpoint that accepts queries in plain text format and reifies them using Relinq you enable the client to perform rich queries to your back-end. Such queries aren't limited to a predefined set of operations, but rather can call any custom code you allow them. Since Relinq fully exposes compilation and marshalling logic, you're free to implement whatever security you might need. For instance, this can be useful for implementing client-side data access layer in web applications.

  * **Invoking cross-tier LINQ queries**. Relinq makes it possible to remotely invoke LINQ queries and includes all infrastructure classes needed to use that functionality. Invoking a remote LINQ query is as simple as running the query against a [simple provider](http://relinq.googlecode.com/svn/trunk/Source/Relinq/Infrastructure/Client/DataContexts/ClientDataContext.cs). The query will then be serialized to a string, passed between tiers, reified with Relinq and executed. The result will be passed back to the caller in JSON format.

  * **Constructing LINQ queries dynamically**. Relinq provides means of building LINQ expressions using trivial string operations, parsing built expressions (given certain conditions are met) and then using them in possibly cross-tier invocations. We also plan to support strongly-typed and object-oriented construction of expression trees with the use of [invocations inlining](http://code.google.com/p/relinq/wiki/Inliner).

### How to play with interactive console? ###
  * Make sure you have .NET Framework 3.5 installed (so far, the interactive console is compiled only for Windows and only for MS .NET Framework).

  * Download the latest featured release from the [downloads page](http://code.google.com/p/relinq/downloads/list).

  * Unpack the `Relinq.Playground.exe` file from the archive along with its two dependencies: `Relinq.dll` and `Antlr3.Runtime.dll`. The package also contains the source code - be sure to check if you wonder how it works. You can also [check out the latest version](http://code.google.com/p/relinq/source/checkout) of source codes if you're really into that.

  * Run the console (`Relinq.Playground.exe`) and enter the following `register ctx as Relinq.Playground.DataContexts.TestServerDataContext from "Relinq.Playground"`. This will tell the compiler that the variable `ctx` in the expressions that you will enter later is bound to an instance of the specified class (the instance is created automatically via a default constructor). The [test data context](http://relinq.googlecode.com/svn/trunk/Source/Relinq.Playground/DataContexts/TestServerDataContext.cs) exposes a couple of [companies](http://relinq.googlecode.com/svn/trunk/Source/Relinq.Playground/Domain/Company.cs) that have some [employees](http://relinq.googlecode.com/svn/trunk/Source/Relinq.Playground/Domain/Employee.cs) working (check the links to see the domain classes and test data).

  * Now you can write expressions in JS (according to [certain rules](http://code.google.com/p/relinq/wiki/UnsupportedJSConstructs)) that will be compiled by Relinq and transformed to strongly-typed C# expression trees. After that interactive console will compiler expression trees into IL and execute the resulting code. Results of the execution will be [serialized to JSON](http://code.google.com/p/relinq/wiki/JsonSerialization) and displayed in the console. If something goes fubar, an exception text and a full stack trace will be printed instead. An example of the expression you can enter: `ctx.Companies.ElementAt(0).Employees.Select(function(e){return e.FirstName})`.

http://relinq.googlecode.com/svn/wiki/images/sampleOfUsage.PNG